import os

# To run locally:
# snakemake --keep-going --cores 4

# To run on tars:
# /local/gensoft2/exe/snakemake/3.5.4/bin/snakemake --configfile /pasteur/homes/azhukova/projects/PASTML/cytopast/examples/HIV1C/snakemake/config_tars.yaml --keep-going --resources tnt=1 -p --cluster "sbatch -c {threads} -o {params.name}.log -e {params.name}.log --mem {params.mem} -p bioevo --qos=bioevo -A bioevo -J {params.name}" --jobs 500

configfile: "config.yaml"
localrules: all, tnt

src_command = config['src']
py_config = config['py_config']

folder = os.path.abspath(config["folder"])
data_dir = os.path.join(folder, config['data_dir'])
fasta_la = os.path.join(data_dir, config['fasta_la'])
fasta_la_c = os.path.join(data_dir, 'aln.la.c.fa')
fasta_phy = os.path.join(data_dir, config['fasta_phylotype'])
data_phy = os.path.join(data_dir, config['data_phylotype'])
data_la = os.path.join(data_dir, 'data_la.tab')
data = os.path.join(data_dir, 'data.tab')
metadata = os.path.join(data_dir, 'metadata.tab')
metadata = os.path.join(data_dir, 'metadata_loc.tab')
fasta_phy_ids = os.path.join(data_dir, 'aln.phy.c.outgroup.fa')
fa = os.path.join(data_dir, 'aln.fa')
aln = os.path.join(data_dir, 'alignment.fa')

maps_dir = 'nondated_maps'
n=5
m=3
DRMS = ['RT:M184V', 'RT:K103N', 'RT:D67N']
tree_types = ['raxml', 'phyml', 'fast']
location_col = 'Loc'

rule all:
    input:
        expand(os.path.join(data_dir, maps_dir, '{type}', 'Location_{loc}', 'map_{n}_{type}_{model}_{loc}.html'),
                            n=range(n), type=tree_types, model='F81', loc=location_col),
        expand(os.path.join(data_dir, maps_dir, '{type}', '{m}_top_DRMs', 'map_{n}_{type}_{model}_{m}_top_SDRMS.html'),
                            n=range(n), type=tree_types, model='F81', loc=location_col, m=m),
        expand(os.path.join(data_dir, maps_dir, '{type}', 'DRM_{DRM}', 'map_{n}_{type}_{model}_{DRM}.html'),
                            n=range(n), type=tree_types, model='F81', DRM=DRMS),
        expand(os.path.join(data_dir, maps_dir, '{type}', 'DRM_{DRM}_Location_{loc}',
                            'map_{n}_{type}_{model}_{DRM}_{loc}.html'), n=range(n), type=tree_types, model='F81',
                            DRM=DRMS, loc=location_col),
        expand(os.path.join(data_dir, maps_dir, '{type}', '{m}_top_DRMs_Location_{loc}',
                            'map_{n}_{type}_{model}_{loc}_{m}_top_SDRMS.html'), n=range(n), type=tree_types,
                            model='F81', m=m, loc=location_col),

rule la_metadata:
    """Keep only C sequences and update the ids"""
    input:
        fa = fasta_la
    output:
        fa = fasta_la_c,
        data = data_la
    params:
        mem = 2000,
        name = 'la_filter'
    threads: 1
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/la_metadata.py --output_data {output.data} --output_fa {output.fa} --input_fa {input.fa}
        """)


rule loc_metadata:
    """Add Loc columns to metadata"""
    input:
        data = metadata
    output:
        data = metadata_loc
    params:
        mem = 2000,
        name = 'loc_md'
    threads: 1
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/map_location.py --output_data {output.data} --input_data {input.data}
        """)


rule rename_phy:
    """Update the ids"""
    input:
        fa = fasta_phy,
        data = data_phy
    output:
        fa = fasta_phy_ids,
    params:
        mem = 2000,
        name = 'phy_renamer'
    threads: 1
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/rename_phy.py --input_data {input.data} --output_fa {output.fa} --input_fa {input.fa}
        """)


rule merge_aln:
    '''Merges LA and Phylotype alignment'''
    input:
        fa_phy = fasta_phy_ids,
        fa_la = fasta_la_c,
    output:
        fa = fa,
    params:
        mem = 2000,
        name = 'aln_merge',
        mafft = config['mafft']
    threads: 8
    run:
        shell("""
            {src_command}
            {params.mafft} --thread {threads} --memsave --retree 1 --maxiterate 0 --add {input.fa_la} --keeplength {input.fa_phy} > {output.fa}

            {py_config}
            python3 {folder}/py/filter_unique_fasta_seq.py --fa {output.fa}
        """)


rule merge_md:
    '''Merges LA and Phylotype metadata'''
    input:
        data_phy = data_phy,
        data_la = data_la
    output:
        data = data,
    params:
        mem = 2000,
        name = 'md_merge',
    threads: 8
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/merge_md.py --data_phy {input.data_phy} --data_la {input.data_la} --data {output.data}
        """)


rule drm_data:
    '''
    Extract information about DRMs from Stanford DB (with sierra) and reformat it into a table.
    '''
    input:
        fasta = fa,
    output:
        gql = temp(os.path.join(data_dir, 'sierra.gql')),
        json = temp(os.path.join(data_dir, 'pol.json')),
        tab = os.path.join(data_dir, 'drm_data.tab')
    params:
        mem = 2000,
        name = 'sierra',
    threads: 1
    run:
        shell("""
            {src_command}
            echo '''inputSequence {{
    header
}},
subtypeText,
alignedGeneSequences {{
    gene {{ name }},
    SDRMs:mutations(filterOptions:[SDRM]) {{
        text
    }}
}}''' > {output.gql}

            sierrapy fasta {input.fasta} -o {output.json} -q {output.gql}

            {py_config}
            python3 {folder}/py/drm_data.py --json {output.json} --data {output.tab}
        """)


rule metadata:
    '''
    Reformat the information about DRMs extracted from Stanford DB (with sierra) together with other metadata.
    '''
    input:
        drm_tab = os.path.join(data_dir, 'drm_data.tab'),
        data = data,
        fa = fa
    output:
        data = metadata,
        fa = aln
    params:
        mem = 2000,
        name = 'metadata'
    threads: 1
    run:
        shell("""
            {src_command}
            {py_config}
            python3 {folder}/py/prepare_metadata.py --drm_tab {input.drm_tab} --input_data {input.data} \
            --output_data {output.data} --output_fa {output.fa} --input_fa {input.fa}
        """)

rule clean_alignment:
    '''
    Removes the positions of DRMs from the alignment, in order not to influence the evolutionary history by drug
    selective pressure.
    '''
    input:
        fa = '{bf}alignment.fa',
        data = metadata
    output:
        fa = '{bf}alignment.nodrm.fa',
    params:
        mem = 1000,
        name = 'clean',
        PR_start_pos = 0,
        RT_start_pos = 99,
    threads: 1
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/clean_aln.py --input_data {input.data} \
            --output_fa {output.fa} --input_fa {input.fa} --PR_start_pos {params.PR_start_pos} --RT_start_pos {params.RT_start_pos}
        """)


rule convert_alignment:
    '''
    Filter and convert a fasta alignment to another format.
    '''
    input:
        fa = '{bf}alignment{af}.fa'
    output:
        fa = '{bf}alignment{af}.{format}'
    params:
        mem = 1000,
        name = 'aln_{format}',
        format = '{format}'
    threads: 1
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/convert_aln.py --output_fa {output.fa} --input_fa {input.fa} --format {params.format}
        """)

rule tnt:
    '''
    Generates most parsimonious trees with TNT.
    The tnt script is based on the explanations from here:
    http://phylobotanist.blogspot.fr/2015/03/parsimony-analysis-in-tnt-using-command.html
    '''
    input:
        os.path.join(data_dir, 'alignment.nodrm.tnt')
    output:
        os.path.join(data_dir, 'pars_trees.nex'),
    params:
        mem = 1000,
        name = 'tnt',
        tnt = config['tnt'],
        num_trees = n,
        dir_name = data_dir,
        file_name = 'pars_trees.nex'
    resources: tnt=1
    threads: 4
    run:
        # for some reason TNT does not process a full path to the result tree file correctly
        # so we need to cd to its dir and use the local path instead

        shell("""
            {src_command}
            cd {params.dir_name}

            echo '''mxram 1024;
nstates DNA;
nstates NOGAPS;
procedure {input};
log {output}.log;
hold {params.num_trees};
mult;
bbreak=tbr;
taxname=;
export - {params.file_name};
quit

''' > {output}.run
            {params.tnt} procedure {output}.run
            rm {output}.run
            rm {output}.log
        """)

rule nex2nwk:
    '''
    Converts trees from a nexus file to multiple newick files.
    '''
    input:
        trees = os.path.join(data_dir, 'pars_trees.nex')
    output:
        expand(os.path.join(data_dir, '{n}', 'pars_tree.nwk'), n=range(n)),
        log = os.path.join(data_dir, 'pars_trees.log')
    threads:
        1
    params:
        mem = 1000,
        tree_pattern = os.path.join(data_dir, '%s', 'pars_tree.nwk'),
        name = 'nex2nwk',
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/nex2nwk.py --trees {input.trees} --pattern {params.tree_pattern} --log {output.log}
        """)

rule fasttree:
    '''
    Given a layout, reconstructs a tree in quick and dirty way.
    '''
    input:
        aln = os.path.join(data_dir, 'alignment.nodrm.phylip'),
        tree = os.path.join(data_dir, '{n}', 'pars_tree.nwk')
    output:
        os.path.join(data_dir, '{n}', 'fast_tree.nwk')
    threads: 6
    params:
        mem = 8000,
        name='fastt_{n}',
        fasttree = config['fasttree']
    run:
        shell("""
            {src_command}
            {params.fasttree} -gamma -nt -gtr -cat 6 -intree {input.tree} < {input.aln} > {output}
        """)


rule phyml:
    '''
    Given a group of tips that are close together reconstructs the subtrees for them.
    '''
    input:
        aln = os.path.join(data_dir, 'alignment.nodrm.phylip'),
        tree = os.path.join(data_dir, '{n}', 'pars_tree.nwk')
    output:
        tree = os.path.join(data_dir, '{n}', 'phyml_tree.nwk'),
        log = temp(os.path.join(data_dir, '{n}', 'phyml_tree.log'))
    threads:
        12
    params:
        mem = 4000,
        name = 'ph_{n}',
        phyml = config['phyml'],
        aln = os.path.join(data_dir, '{n}', 'aln_sequences_{n}.phylip')
    run:
        shell("""
            {src_command}
            cp {input.aln} {params.aln}
            {params.phyml} -i {params.aln} -d nt -m GTR -o tlr -f e -t e -c 6 -a e -s RAND -u {input.tree}
            mv {params.aln}_phyml_tree* {output.tree}
            mv {params.aln}_phyml_stats* {output.log}
            rm {params.aln}
        """)


rule raxml:
    '''
    Given a group of tips that are close together reconstructs the subtrees for them.
    '''
    input:
        aln = os.path.join(data_dir, 'alignment.nodrm.phylip'),
        tree = os.path.join(data_dir, '{n}', 'pars_tree.nwk')
    output:
        tree = os.path.join(data_dir, '{n}', 'raxml_tree.nwk'),
        log = os.path.join(data_dir, '{n}', 'raxml.log'),
    threads:
        12
    params:
        mem = 8000,
        name = 'rx_{n}',
        raxml = config['raxml'],
        dir = os.path.join(data_dir, '{n}'),
        n = '{n}'
    run:
        shell("""
            {src_command}
            cd {params.dir}
            {params.raxml} -f e  -t  {input.tree} -m GTRGAMMA -s {input.aln} -c 6 -n "RAXML_{params.n}" -T {threads} -b 239 -N 1000
            mv "{params.dir}/RAxML_result.RAXML_{params.n}" {output.tree}
            mv "{params.dir}/RAxML_log.RAXML_{params.n}" {output.log}
        """)

rule extract_dates:
    '''
    Reformat metadata into date file readable by LSD.
    '''
    input:
        tab = metadata
    output:
        tab = os.path.join(data_dir, 'dates.tab')
    params:
        mem = 1000,
        name = 'dates',
        date_col = 'Year',
        c_tip = 'b(1980,2017)'
    threads: 1
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/extract_dates.py --data {input.tab} --dates {output.tab} --c_tip params.c_tip --date_col params.date_col
        """)

rule get_seq_ids:
    '''
    Extract sequence ids of interest.
    '''
    input:
        tab = metadata
    output:
        tab = os.path.join(data_dir, 'ids_{subtype}.txt')
    params:
        mem = 500,
        name = 'ids_{subtype}',
        col_value = '{subtype}',
        col_name = 'Subtype'
    threads: 1
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/get_seq_ids.py --input_data {input.tab} --output_data {output.tab} --col_name {params.col_name} --col_value {params.col_value}
        """)

rule root:
    '''
    Root a tree using an outgroup.
    '''
    input:
        tree = '{tree}.nwk',
        ids = [os.path.join(data_dir, 'ids_C.txt')]
    output:
        tree = '{tree}.rooted.nwk'
    threads: 1
    params:
        mem = 500,
        name='root',
        is_ingroup='--ingroup'
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/root.py --input_tree {input.tree} --ids {input.ids} --output_tree {output.tree} {params.is_ingroup}
        """)

rule collapse:
    '''
    Collapses branches using a certain criterion.
    '''
    input:
        tree = '{tree}.nwk',
    output:
        tree = '{tree}.collapsed_{feature}_{threshold}.nwk',
    threads: 1
    params:
        mem = 500,
        name='collapse_{feature}_{threshold}',
        threshold='{threshold}',
        feature='{feature}'
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/collapse.py --input_tree {input.tree} --feature {params.feature} --output_tree {output.tree} --threshold {params.threshold}
        """)

rule date:
    '''
    Date a tree.
    '''
    input:
        tree = '{tree}.nwk',
        dates = os.path.join(data_dir, 'dates.tab')
    output:
        tree = '{tree}.dated.nwk',
        log = '{tree}.lsd.log',
    threads:
        1
    params:
        mem = 2000,
        name = 'date',
        lsd = config['lsd']
    run:
        shell("""
            {src_command}
            {params.lsd} -i {input.tree} -d {input.dates} -v 2 -c -s 882 -f 1000 -t 1e-3
            mv {input.tree}.result.date.newick {output.tree}
            mv {input.tree}.result {output.log}
            rm {input.tree}.result.*
        """)

rule top_drms:
    '''
    Selects n most common SDRMs.
    '''
    input:
        tab = metadata
    output:
        top_drm_file = os.path.join(data_dir, 'top_{n}_SDRMS.tab')
    threads:
        1
    params:
        mem = 1000,
        name = 'top_{n}',
        num_mutations = '{n}'
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/top_drms.py --input {input.tab} --output {output.top_drm_file} --n {params.num_mutations}
        """)


rule pastml_tree:
    '''
    Copies a tree with a certain name into a pastml tree
    '''
    input:
        # collapse less than a day distances: 1 / 365 = 0.0027
        tree=os.path.join(data_dir, '{n}', '{type}_tree.rooted.collapsed_support_0.5.collapsed_dist_0.nwk'),
    output:
        tree=os.path.join(data_dir, '{n}', 'pastml_{type}_tree.nwk'),
    threads:
        1
    params:
        mem = 1000,
        name = 'name_{n}'
    run:
        shell("""
            {src_command}
            {py_config}

            python3 {folder}/py/name_tree.py --input_tree {input.tree} --output_tree {output.tree}
        """)


rule pastml_top_drms_loc:
    '''
    Reconstructs tree ancestral states with PASTML and visualises the result.
    '''
    input:
        tree = os.path.join(data_dir, '{n}', 'pastml_{type}_tree.nwk'),
        data = metadata,
        top_drm_file = os.path.join(data_dir, 'top_{m}_SDRMS.tab')
    output:
        map = os.path.join(data_dir, maps_dir, '{type}', '{m}_top_DRMs_Location_{loc}', 'map_{n}_{type}_{model}_{loc}_{m}_top_SDRMS.html')
    threads:
        4
    params:
        mem = 4000,
        name = 'pastml_{n}',
        loc = '{loc}',
        model = '{model}',
        date_col = 'Year'
    run:
        shell("""
            {src_command}
            {py_config}
        """)
        with open(input.top_drm_file, 'r') as f:
            columns=f.read().split(' ')

        shell("""
            cytopast --tree {input.tree} --data {input.data} --html_compressed {output.map} \
            --model {params.model} --columns {columns} {params.loc} --name_column {params.loc} -v \
            --date_column {params.date_col}
        """)

rule pastml_top_drms:
    '''
    Reconstructs tree ancestral states with PASTML and visualises the result.
    '''
    input:
        tree = os.path.join(data_dir, '{n}', 'pastml_{type}_tree.nwk'),
        data = metadata,
        top_drm_file = os.path.join(data_dir, 'top_{m}_SDRMS.tab')
    output:
        map = os.path.join(data_dir, maps_dir, '{type}', '{m}_top_DRMs', 'map_{n}_{type}_{model}_{m}_top_SDRMS.html')
    threads:
        4
    params:
        mem = 4000,
        name = 'pastml_{n}',
        model = '{model}',
        date_col = 'Year'
    run:
        shell("""
            {src_command}
            {py_config}
        """)

        with open(input.top_drm_file, 'r') as f:
            columns=f.read().split(' ')

        shell("""
            cytopast --tree {input.tree} --data {input.data} --html_compressed {output.map} \
            --model {params.model} --columns {columns} -v \
            --date_column {params.date_col}
        """)

rule pastml_drm:
    '''
    Reconstructs tree ancestral states with PASTML and visualises the result.
    '''
    input:
        tree = os.path.join(data_dir, '{n}', 'pastml_{type}_tree.nwk'),
        data = metadata,
    output:
        map = os.path.join(data_dir, maps_dir, '{type}', 'DRM_{DRM}', 'map_{n}_{type}_{model}_{DRM}.html')
    threads:
        4
    params:
        mem = 4000,
        name = 'pastml_{n}',
        model = '{model}',
        date_col = 'Year',
        drm = '{DRM}'
    run:
        shell("""
            {src_command}
            {py_config}
            cytopast --tree {input.tree} --data {input.data} --html_compressed {output.map} \
            --model {params.model} --columns {params.drm} -v \
            --date_column {params.date_col}
        """)

rule pastml_drm_loc:
    '''
    Reconstructs tree ancestral states with PASTML and visualises the result.
    '''
    input:
        tree = os.path.join(data_dir, '{n}', 'pastml_{type}_tree.nwk'),
        data = metadata,
    output:
        map = os.path.join(data_dir, maps_dir, '{type}', 'DRM_{DRM}_Location_{loc}',
                           'map_{n}_{type}_{model}_{DRM}_{loc}.html')
    threads:
        4
    params:
        mem = 4000,
        name = 'pastml_{n}',
        model = '{model}',
        date_col = 'Year',
        drm = '{DRM}',
        loc = '{loc}'
    run:
        shell("""
            {src_command}
            {py_config}
            cytopast --tree {input.tree} --data {input.data} --html_compressed {output.map} \
            --model {params.model} --columns {params.drm} {params.loc} --verbose \
            --date_column {params.date_col} --name_column {params.loc}
        """)

rule pastml_loc:
    '''
    Reconstructs tree ancestral states with PASTML and visualises the result.
    '''
    input:
        tree = os.path.join(data_dir, '{n}', 'pastml_{type}_tree.nwk'),
        data = metadata
    output:
        map = os.path.join(data_dir, maps_dir, '{type}', 'Location_{loc}', 'map_{n}_{type}_{model}_{loc}.html')
    threads:
        4
    params:
        mem = 4000,
        name = 'pastml_{n}',
        loc = '{loc}',
        model = '{model}',
        dir = os.path.join(data_dir, 'pastml'),
        date_col = 'Year'
    run:
        shell("""
            {src_command}
            {py_config}
            cytopast --tree {input.tree} --data {input.data} --html_compressed {output.map} \
            --model {params.model} --columns {params.loc} -v \
            --date_column {params.date_col}
        """)
